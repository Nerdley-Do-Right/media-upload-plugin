<div data-role="page" class="page type-interior pluginConfigurationPage RemoteUploadConfigPage"
	 data-require="emby-button,emby-select,emby-checkbox">
	<div data-role="content">
		<div class="content-primary">
			<form id="RemoteUploadForm">
				<div class="inputContainer">
					<label class="inputLabel inputLabelUnfocused" for="uploaddir">Choose upload directory</label>
					<ul id="uploaddirslist" style="padding-left: 0; margin-top: 0; list-style-position: inside;"></ul>
					<label class="inputLabel inputLabelUnfocused" for="uploaddir">Add upload directory</label>
					<input id="uploaddirinput" name="uploaddir" type="text" is="emby-input" placeholder="If you see this, refresh"/>
					<div class="fieldDescription">Path where files will get saved</div>
				</div>
				<div>
					<button is="emby-button" type="submit" class="raised button-submit block emby-button">
						<span>Save</span>
					</button>
				</div>
			</form>
			<form id="RemoteFileUploadForm" enctype="multipart/form-data" action="/mediaupload/upload" style="margin-top: 50px;">
				<div class="inputContainer">
					<h2>Upload file</h2>
					<input type="file" name="files" required multiple id="uploadfile" is="emby-input" value="Upload file"/>
				</div>
				<div>
					<button is="emby-button" type="submit" class="raised button-submit block emby-button">
						<span id="progress_file">Upload</span>
					</button>
				</div>
			</form>
			<form id="RemoteURLUploadForm" enctype="multipart/form-data" action="/mediaupload/upload_url" style="margin-top: 50px;">
				<div class="inputContainer">
					<h2>Download from URL</h2>
					<input type="text" name="url" required id="uploadurl" is="emby-input" placeholder="https://download.com/file.mp4"/>
				</div>
				<div>
					<button is="emby-button" type="submit" class="raised button-submit block emby-button">
						<span id="progress_url">Download</span>
					</button>
				</div>
			</form>
			<form id="RemoteBulkURLUploadForm" enctype="multipart/form-data" style="margin-top: 50px;" action="/mediaupload/upload_bulk_url">
				<div>
					<label is="emby-button" class="raised button-submit block emby-button" for="uploadbulkurlsubmit" id="bulkprogress_url">Download all links from txt</label>
					<input type="file" id="uploadbulkurlsubmit" style="display: none;" onchange="bulkDownload()">
					<input type="submit" style="display: none;">
				</div>
			</form>
			<form id="GetTasksForm" enctype="multipart/form-data" action="/mediaupload/get_tasks" style="margin-top: 50px;">
				<p>Tasks:</p>
				<button is="emby-button" type="submit" class="raised button-submit block emby-button" style="width: max-content;">
					<span>Refresh</span>
				</button>
				<div class="current_tasks"></div>
			</form>
			<form id="RemoteDownload" enctype="multipart/form-data" action="/mediaupload/download">
				<div class="inputContainer">
					<h2>Download from server</h2>
					<input type="text" name="path" required id="downloadpath" is="emby-input" placeholder="File path"/>
				</div>
				<div>
					<button is="emby-button" type="submit" class="raised button-submit block emby-button">
						<span id="download_button">Download</span>
					</button>
				</div>
			</form>
			<form id="RemoteDirectory" enctype="multipart/form-data" action="/mediaupload/directory">
				<div class="inputContainer">
					<h2>Log files in directory</h2>
					<input type="text" name="path" required id="downloadpathfolder" is="emby-input" placeholder="Folder path"/>
				</div>
				<div>
					<button is="emby-button" type="submit" class="raised button-submit block emby-button">
						<span id="directory_button">Show files</span>
					</button>
				</div>
				<div id="folderContentDisplay">
					<!-- Files and Folders -->
					<!-- If you click on a folder it you will navigate it. If you click on a file you can download it.-->
				</div>
			</form>
        </div>
    </div> 	
	<script>
		var RemoteUploadConfig = {
			pluginUniqueId: 'b5a2d6b3-c5f4-4f88-aed4-5f3e9877d0a6',
		};

		document.querySelector(".RemoteUploadConfigPage").addEventListener("pageshow", async function () {
			updateUI();
			await load();
		});

		function updateUI() {
			ApiClient.getPluginConfiguration(RemoteUploadConfig.pluginUniqueId).then(function (config) {
				// Update placeholder
				document.getElementById('uploaddirinput').setAttribute("placeholder", config.uploaddir);

				// Clear and populate list
				const list = document.getElementById('uploaddirslist');
				list.innerHTML = "";
				config.uploaddirs.forEach(function (dir) {
					const li = document.createElement('li');
					li.style.display = "flex";
					li.style.justifyContent = "space-between";
					li.style.alignItems = "center";
					
					const span = document.createElement('span');
					span.textContent = dir;
					span.style.cursor = "pointer";

					if (dir === config.uploaddir) {
						li.style.listStyleType = "disc";
					}
					else {
						li.style.listStyleType = "circle";
					}

					span.addEventListener("click", function () {
						config.uploaddir = dir;
						document.getElementById('uploaddirinput').setAttribute("placeholder", dir);
						ApiClient.updatePluginConfiguration(RemoteUploadConfig.pluginUniqueId, config).then(function (result) {
							Dashboard.processPluginConfigurationUpdateResult(result);
							updateUI();
						});
					});

					// Remove button
					const removeBtn = document.createElement('p');
					removeBtn.textContent = "Ã—";
					removeBtn.style.border = "none";
					removeBtn.style.background = "none";
					removeBtn.style.cursor = "pointer";
					removeBtn.style.color = "red";
					removeBtn.style.fontSize = "1.2em";
					removeBtn.style.margin = "0";

					removeBtn.addEventListener("click", function () {
						config.uploaddirs = config.uploaddirs.filter(p => p !== dir);
						if (config.uploaddir === dir) {
							config.uploaddir = config.uploaddirs[0] || "";
						}
						ApiClient.updatePluginConfiguration(RemoteUploadConfig.pluginUniqueId, config).then(function (result) {
							Dashboard.processPluginConfigurationUpdateResult(result);
							updateUI();
						});
					});

					li.appendChild(span);
					li.appendChild(removeBtn);
					list.appendChild(li);
				});

				Dashboard.hideLoadingMsg();
			});
		}

		document.querySelector("#RemoteUploadForm").addEventListener('submit', function (e) {
			e.preventDefault();

			ApiClient.getPluginConfiguration(RemoteUploadConfig.pluginUniqueId).then(function (config) {
				const newDir = document.getElementById('uploaddirinput').value.trim();
				if (newDir && !config.uploaddirs.includes(newDir)) {
					config.uploaddirs.push(newDir);
				}
				config.uploaddir = newDir || config.uploaddir;
				document.getElementById('uploaddirinput').value = "";
				document.getElementById('uploaddirinput').setAttribute("placeholder", config.uploaddir);

				ApiClient.updatePluginConfiguration(RemoteUploadConfig.pluginUniqueId, config).then(function (result) {
					Dashboard.processPluginConfigurationUpdateResult(result);
					updateUI();
				});
			});

			return false;
		});

		async function fetchWithAuth(url, method, body) {
			const reqInit = {
				method: method,
				headers: {
					Authorization: "MediaBrowser Token=" + ApiClient.accessToken(),
				},
				body: body,
			};

			return await fetch(url, reqInit);
		}

		async function load() {
			let url = document.querySelector("#GetTasksForm").action
			const res = await fetchWithAuth(url, "GET", null)
			let tasks = await res.json();

			return tasks;
		}

		let progress = document.getElementById("progress_file");
		let chunk_size = 28000000;
		
		document.querySelector("#RemoteFileUploadForm")
			.addEventListener("submit", async function(e) {
				e.preventDefault();

				let formElement = document.getElementById("RemoteFileUploadForm");
				let formData = new FormData(formElement);
				let url = formElement.action;

				for (let [key, file] of formData.entries()) {
					let chunk_index = 0;
					let start = 0;

					if (file instanceof File) { 
						while (start < file.size) {
							const chunk = file.slice(start, start+chunk_size);
							let chunk_form = new FormData();
							chunk_form.set("file", chunk, file.name)
							chunk_form.set("chunkIndex", chunk_index)
							chunk_form.set("totalChunks", Math.ceil(file.size / chunk_size))

							// Request
							try {
								const res = await fetchWithAuth(url, "POST", chunk_form);
								if (res.ok) {
									console.log("Successfully saved chunk " + chunk_index);
									let progress_value = ((chunk_index+1)/Math.ceil(file.size / chunk_size))*100
									progress.textContent = file.name + " " + progress_value.toString() + "%"
									start += chunk_size
									chunk_index++;
								}
								else {
                                    const result = await res.json();
                                    progress.textContent = result.message || 'Upload failed!';
                                    return;
                                }
								
							} catch (error) {
								progress.textContent = "Upload failed!"
								console.log('Error:', error);
								return;
							}
						}
					}
				}
				/* If upload finished successfully */
				progress.textContent = "Upload finished";
				document.getElementById("uploadfile").value = "";
				return;
			});

			document.getElementById("uploadfile").addEventListener("change", (event) => {
				progress.textContent = "Upload";
			});

			/* Upload from URL */
			let progress_url = document.getElementById("progress_url");
			document.querySelector("#RemoteURLUploadForm").addEventListener("submit", async function(e) {
				e.preventDefault();
				
				let formElement = document.getElementById("RemoteURLUploadForm");
				let formData = new FormData();
				formData.set("url", document.getElementById("uploadurl").value);

				let url = formElement.action;

				try {
					progress_url.textContent = "Download queued..."
					const res = await fetchWithAuth(url, "POST", formData)
					if (res.ok) {
						progress_url.textContent = "Download has started..."
						document.getElementById("uploadurl").value = "";
						return;
					}
					else {
						const result = await res.json();
						progress_url.textContent = result.message || "Download failed!";
						return;
					}
				}
				catch (error) {
					progress_url.textContent = "Download failed!"
					return;
				}
			});

			let bulkprogress_url = document.querySelector("#bulkprogress_url");

			function readFileAsText(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();

					reader.onload = function(event) {
						resolve(event.target.result);
					};

					reader.onerror = function(event) {
						reject(event.target.error);
					};

					reader.readAsText(file);
				});
			}
			let links = [];
			async function bulkDownload() {
				const fileInput = document.querySelector("#uploadbulkurlsubmit");

				if (fileInput.files.length > 0) {
					const file = fileInput.files[0];
					
					try {
						const fileContent = await readFileAsText(file);
						links = fileContent.split('\n').map(line => line.trim()).map(line => line.endsWith('/') ? line.slice(0, -1) : line).filter(line => line.length > 0);

						// Reset the form after processing the file
						document.querySelector("#RemoteBulkURLUploadForm").reset();
					} catch (error) {
						console.error('Error processing file:', error);
					}
				} else {
					alert("No file selected!");
				}
				
				let url = document.getElementById("RemoteBulkURLUploadForm").action;

				let formData = new FormData();
				links.forEach(link => {
					formData.append("urls", link);
				});

				try {
					const res = await fetchWithAuth(url, "POST", formData);
					if (res.ok) {
						bulkprogress_url.textContent = `Downloads are starting.`;
					}
					else {
						const result = await res.json();
						bulkprogress_url.textContent = result.message || "Serverside error!";
					}
				}
				catch (error) {
					bulkprogress_url.textContent = error;
				}
			}

			document.getElementById("uploadurl").addEventListener("change", function() {
				progress_url.textContent = "Download";
			})

			document.querySelector("#GetTasksForm").addEventListener("submit", async function(e) {
				// If the Refresh Tasks button gets pressed
				e.preventDefault();

				// Get all ongoing tasks with load()
				let tasks = await load();
				let curr_tasks = document.querySelector(".current_tasks");
				curr_tasks.innerHTML = "";

				// Append all tasks to the tasks div
				for (let i = 0; i < tasks.length; i++) {
					// Each task is another div which consits of the filename and a cancel button
					// Each cancel button will have the cancellation token as their name and an onclick attribute to cancel the task
					let task_div = document.createElement("div");
					task_div.setAttribute("style", "display: flex; flex-direction: row; gap: 10px;")

					let task = document.createElement("p");
					task.innerText = tasks[i]["FileName"]

					let task_progress = document.createElement("p");

					let filesizenow = convertSize(parseInt(tasks[i]["FileSizeNow"]));
					let filesize = convertSize(parseInt(tasks[i]["FileSize"]));

					task_progress.innerText = filesizenow + " out of " + filesize;

					let task_cancel = document.createElement("p");
					task_cancel.innerText = "Cancel";
					task_cancel.name = tasks[i]["Key"];
					task_cancel.style["cursor"] = "pointer";
					task_cancel.setAttribute("onclick", "cancelTask(this)");

					// Append both the task file name and the cancel button to the parent div
					task_div.appendChild(task);
					task_div.appendChild(task_progress);
					task_div.appendChild(task_cancel);

					// Append this parent div to the tasks div
					curr_tasks.appendChild(task_div);
				}
			})

			async function cancelTask(param) {
				// Create form data with the cancellation key
				let form = new FormData()
				form.set("cancellationKey", param.name)
				try {
					param.innerText = "Cancelling...";
					param.removeAttribute("onclick");
					// Request the cancel and get the result
					const req = await fetchWithAuth("/mediaupload/upload_cancel", "POST", form);
					const res = await req.json();
					if (res.ok) {
						param.innerText = "Cancelled successfully";
					}
					else {
						param.innerText = res.message || "Something went wrong";
					}
					
				}
				catch (error) {
					param.innerText = "Something went wrong";
				}
				return;
			}

			function convertSize(bytes) {
				let size = 0;
				let dict = ["Bytes", "KB", "MB", "GB", "TB", "PB", "Liar"]
				while (bytes >= 1024 && size < dict.length - 1) {
					bytes = bytes / 1024;
					size++;
				}
				let final = bytes.toFixed(2) + ' ' + dict[size];
				return final;
			}

			/* Download */
            remoteDownload = document.querySelector("#RemoteDownload");
            remoteDownload.addEventListener("submit", async function(e) {
                e.preventDefault();
				await doRemoteDownload();
            });
			async function doRemoteDownload() {
				let formData = new FormData(remoteDownload);
                let url = remoteDownload.action;

                try {
                    const res = await fetchWithAuth(url, "POST", formData);

                    if (res.ok) {
                        document.querySelector("#download_button").innerText = "Downloading..."
                        const blob = await res.blob(); // Get the file as a blob
                        const downloadUrl = window.URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.style.display = "none";
                        a.href = downloadUrl;
                        a.download = formData.get("path").split('/').pop().split('\\').pop().split('//').pop(); // Set the filename
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(downloadUrl);
                        document.querySelector("#download_button").innerText = "Download";
                        return;
                    }
                    else {
                        const result = await res.json();
                        document.querySelector("#download_button").textContent = result.message || "Download failed!";
                        return;
                    }
                }
                catch (error) {
                    document.querySelector("#download_button").textContent = "Download failed!"
                    return;
                }
			}

			document.querySelector("#RemoteDirectory").addEventListener("submit", async function(e) {
				e.preventDefault();
				await listDirectory();
			})
			async function listDirectory() {
				try {

					const formData = new FormData(document.querySelector("#RemoteDirectory"));
					document.getElementById("folderContentDisplay").innerHTML = "";
					const res = await fetchWithAuth(document.querySelector("#RemoteDirectory").action, "POST", formData)
					if (res.ok) {
						let files = await res.json();
	
						let oldPath = document.getElementById("downloadpathfolder").value;
						if (!oldPath.endsWith("/")) {
							oldPath += "/";
						}
	
						for (var i = 0; i<files.length; i++) {
							let element = document.createElement("ul");
							element.innerHTML = files[i];
							element.style = "cursor: pointer;";
							if (files[i].endsWith("/")) {
								// Navigate to dir
								element.onclick = async function() {
									document.getElementById("downloadpathfolder").value = oldPath + element.innerHTML;
									await listDirectory();
								};
							}
							else {
								// Download file
								element.onclick = async function() {
									const confirmDownload = window.confirm("Do you want to download this file?");
									if (confirmDownload) {
										document.getElementById("downloadpath").value = oldPath + element.innerHTML;
										await doRemoteDownload();
									}
								}
							}
							document.querySelector("#folderContentDisplay").appendChild(element);
						}
						return;
					}
					else {
						const result = await res.json();
						document.querySelector("#directory_button").innerText = result.message || "Server error!";
						return;
					}
				}
				catch {
					document.querySelector("#directory_button").textContent = "Local error!"
                    return;
				}
			}
	</script>
</div>